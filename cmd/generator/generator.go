package main

//go:generate go run ./generator.go

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"html/template"
	"io"
	"log"
	"net/http"
	"os"
	"path/filepath"
	"strings"

	"gopkg.in/yaml.v3"

	"github.com/bl4ko/netbox-ssot/internal/devices"
)

const (
	githubRepoURL    = "https://api.github.com/repos/netbox-community/devicetype-library/contents/device-types"
	shaCommitFile    = "../../internal/devices/sha.txt"
	manufacturerDir  = "../../internal/devices/"
	combinedFile     = "../../internal/devices/combined_data.go"
	githubRepo       = "devicetype-library"
	githubRepoSubdir = "device-types"
	githubOwner      = "netbox-community"
	branch           = "master"
)

const manufacturerTemplate = `// Code generated by go generate; DO NOT EDIT.
package devices

var DeviceTypesMap{{ .Manufacturer }} = map[string]DeviceData{
{{- range $model, $data := .Devices }}
    "{{ $model }}": {
        Manufacturer: "{{ $data.Manufacturer }}",
        Model: "{{ $data.Model }}",
        Slug: "{{ $data.Slug }}",
        UHeight: {{ $data.UHeight }},
        PartNumber: "{{ $data.PartNumber }}",
        IsFullDepth: {{ $data.IsFullDepth }},
        Airflow: "{{ $data.Airflow }}",
        FrontImage: {{ $data.FrontImage }},
        RearImage: {{ $data.RearImage }},
        SubdeviceRole: "{{ $data.SubdeviceRole }}",
        Weight: {{ $data.Weight }},
        WeightUnit: "{{ $data.WeightUnit }}",
        IsPowered: {{ $data.IsPowered }},
        ConsolePorts: []ConsolePort{
            {{- range $data.ConsolePorts }}
            { Name: "{{ .Name }}", Type: "{{ .Type }}", Label: "{{ .Label }}", Poe: {{ .Poe }} },
            {{- end }}
        },
        ConsoleServerPorts: []ConsoleServerPort{
            {{- range $data.ConsoleServerPorts }}
            { Name: "{{ .Name }}", Type: "{{ .Type }}", Label: "{{ .Label }}" },
            {{- end }}
        },
        PowerPorts: []PowerPort{
            {{- range $data.PowerPorts }}
            { Name: "{{ .Name }}", Label: "{{ .Label }}", Type: "{{ .Type }}", MaximumDraw: {{ .MaximumDraw }}, AllocatedDraw: {{ .AllocatedDraw }} },
            {{- end }}
        },
        PowerOutlets: []PowerOutlet{
            {{- range $data.PowerOutlets }}
            { Name: "{{ .Name }}", Type: "{{ .Type }}", Label: "{{ .Label }}", PowerPort: "{{ .PowerPort }}", FeedLeg: "{{ .FeedLeg }}", MaximumDraw: {{ .MaximumDraw }}, AllocatedDraw: {{ .AllocatedDraw }} },
            {{- end }}
        },
        FrontPorts: []FrontPort{
            {{- range $data.FrontPorts }}
            { Name: "{{ .Name }}", Label: "{{ .Label }}", Type: "{{ .Type }}", RearPort: "{{ .RearPort }}", RearPortPosition: {{ .RearPortPosition }} },
            {{- end }}
        },
        RearPorts: []RearPort{
            {{- range $data.RearPorts }}
            { Name: "{{ .Name }}", Label: "{{ .Label }}", Type: "{{ .Type }}", Positions: {{ .Positions }}, Poe: {{ .Poe }} },
            {{- end }}
        },
        ModuleBays: []ModuleBay{
            {{- range $data.ModuleBays }}
            { Name: "{{ .Name }}", Label: "{{ .Label }}", Position: "{{ .Position }}" },
            {{- end }}
        },
			  DeviceBays: []DeviceBay{
				{{- range $data.DeviceBays }}
            { Name: "{{ .Name }}", Label: "{{ .Label }}" },
            {{- end }}
        },
        InventoryItems: []InventoryItem{
            {{- range $data.InventoryItems }}
            { Name: "{{ .Name }}", Label: "{{ .Label }}", Manufacturer: "{{ .Manufacturer }}", PartID: "{{ .PartID }}" },
            {{- end }}
        },
        Interfaces: []Interface{
            {{- range $data.Interfaces }}
            { Name: "{{ .Name }}", Label: "{{ .Label }}", Type: "{{ .Type }}", MgmtOnly: {{ .MgmtOnly }} },
            {{- end }}
        },
    },
{{- end }}
}
`

const combinedTemplate = `// Code generated by go generate; DO NOT EDIT.
package devices

var DeviceTypesMap = map[string]map[string]DeviceData{
{{- range $index, $Manufacturer := .Manufacturers }}
    "{{ $Manufacturer }}": DeviceTypesMap{{ index $.ManufacturersTrimmed $index }},
{{- end }}
}
`

type RepoContents struct {
	Name string `json:"name"`
	Path string `json:"path"`
	URL  string `json:"url"`
	Type string `json:"type"`
}

type FileResponse struct {
	Content string `json:"content"` // base64 encoded content
}

type LatestCommitSHAResponse struct {
	SHA string `json:"sha"`
}

// Function that fetches and returns the latest commit sha from
// github.com/netbox-community/devicetype-library.
func getLatestCommitSHA(ctx context.Context, owner string, repo string, branch string) (string, error) {
	req, err := http.NewRequestWithContext(ctx, http.MethodGet, fmt.Sprintf("https://api.github.com/repos/%s/%s/commits/%s", owner, repo, branch), nil)
	if err != nil {
		return "", fmt.Errorf("new request with context: %s", err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", os.Getenv("GITHUB_API_TOKEN")))
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return "", fmt.Errorf("default client do: %s", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return "", fmt.Errorf("resp.StatusCode: %d", resp.StatusCode)
	}

	var latestCommitSHAResp LatestCommitSHAResponse
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", fmt.Errorf("read all: %s", err)
	}

	err = json.Unmarshal(body, &latestCommitSHAResp)
	if err != nil {
		return "", fmt.Errorf("unmarshal: %s", err)
	}

	return latestCommitSHAResp.SHA, nil
}

// writeSHAToFile writes SHA of commit to a file named filename.
func writeSHAToFile(sha, filename string) error {
	err := os.WriteFile(filename, []byte(sha), 0644) //nolint:gosec,gomnd
	if err != nil {
		return fmt.Errorf("Failed to write to file: %v", err)
	}
	return nil
}

// Function that reads SHA of commit from a file named filename.
func readSHAFromFile(filename string) (string, error) {
	data, err := os.ReadFile(filename)
	if err != nil {
		return "", fmt.Errorf("Failed to read file: %v", err)
	}
	return string(data), nil
}

// getGtihubSubRepoAndExtractContent calls the url which should be of format
// https://api.github.com/repos/{{owner}}/{{repo}}/contents/{{path}} and returns
// RepoContents representing all subfiles in the repository.
func getGithubSubRepoAndExtractContent(ctx context.Context, url string) ([]RepoContents, error) {
	fmt.Printf("getting dir content with path %s\n", url)

	req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %v", err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", os.Getenv("GITHUB_API_TOKEN")))
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to download content: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("failed to download content: status code %d", resp.StatusCode)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %v", err)
	}

	var repoResponse []RepoContents
	err = json.Unmarshal(body, &repoResponse)
	if err != nil {
		return nil, fmt.Errorf("error unmarshalling repo response: %v", err)
	}
	return repoResponse, nil
}

// getFileContent calls the fileURL which should be of the format
// https://api.github.com/repos/netbox-community/devicetype-library/contents/device-types/Cisco/2951-ISR.yaml?ref=master. And returns the string representation of this file.
func getFileContent(ctx context.Context, fileURL string) ([]byte, error) {
	fmt.Printf("getting file content with path %s\n", fileURL)

	req, err := http.NewRequestWithContext(ctx, http.MethodGet, fileURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %v", err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", os.Getenv("GITHUB_API_TOKEN")))
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to download file: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("failed to download file: status code %d", resp.StatusCode)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %v", err)
	}

	var fileResponse FileResponse
	err = json.Unmarshal(body, &fileResponse)
	if err != nil {
		return nil, fmt.Errorf("error unmarshalling file response: %v", err)
	}

	decoded, err := base64.StdEncoding.DecodeString(fileResponse.Content)
	if err != nil {
		return nil, fmt.Errorf("error decoding base64 content: %v", err)
	}

	return decoded, nil
}

func getObjectFromFile(ctx context.Context, url string) (*devices.DeviceData, error) {
	content, err := getFileContent(ctx, url)
	if err != nil {
		return nil, fmt.Errorf("get file content: %s", err)
	}
	var obj devices.DeviceData
	err = yaml.Unmarshal(content, &obj)
	if err != nil {
		return nil, fmt.Errorf("error unmarshaling file content into object: %s", err)
	}
	return &obj, nil
}

func createManufacturerTemplate(manufacturer string, deviceData map[string]*devices.DeviceData) error {
	manufacturerTrimmed := trimManufacturer(manufacturer)
	filepath := filepath.Join(manufacturerDir, fmt.Sprintf("data_%s.go", manufacturerTrimmed))
	file, err := os.Create(filepath)
	if err != nil {
		return fmt.Errorf("Failed to create file: %v", err)
	}
	defer file.Close()

	data := struct {
		Manufacturer string
		Devices      map[string]*devices.DeviceData
	}{
		Manufacturer: manufacturerTrimmed,
		Devices:      deviceData,
	}

	tmpl, err := template.New("manufacturerTemplate").Parse(manufacturerTemplate)
	if err != nil {
		return fmt.Errorf("Failed to parse template: %v", err)
	}

	err = tmpl.Execute(file, data)
	if err != nil {
		return fmt.Errorf("Failed to execute template: %v", err)
	}
	return nil
}

// Function that trims Manufacturer into a name that can be used as a golang variable name.
func trimManufacturer(manufacturer string) string {
	manufacturer = strings.ReplaceAll(manufacturer, " ", "")
	manufacturer = strings.ReplaceAll(manufacturer, "-", "")
	manufacturer = strings.ReplaceAll(manufacturer, "&", "")
	return manufacturer
}

func createCombinedTemplate(manufacturersOriginal []string, manufacturersTrimmed []string) error {
	file, err := os.Create(combinedFile)
	if err != nil {
		return fmt.Errorf("Failed to create file: %v", err)
	}
	defer file.Close()

	data := struct {
		Manufacturers        []string
		ManufacturersTrimmed []string
	}{
		Manufacturers:        manufacturersOriginal,
		ManufacturersTrimmed: manufacturersTrimmed,
	}

	tmpl, err := template.New("combinedTemplate").Parse(combinedTemplate)
	if err != nil {
		return fmt.Errorf("Failed to parse template: %v", err)
	}

	err = tmpl.Execute(file, data)
	if err != nil {
		return fmt.Errorf("Failed to execute template: %v", err)
	}
	return nil
}

func run() error {
	ctx := context.Background()
	defer ctx.Done()

	// Compare commit SHAs from last generated with the newest
	lastCommitSHA, err := readSHAFromFile(shaCommitFile)
	if err != nil {
		return fmt.Errorf("read SHA from file: %s", err)
	}
	currentCommitSHA, err := getLatestCommitSHA(ctx, githubOwner, githubRepo, branch)
	if err != nil {
		return fmt.Errorf("get latest commit SHA: %s", err)
	}

	if lastCommitSHA == currentCommitSHA {
		fmt.Printf("github.com/%s/%s latest commit is %s. It is the same as last sync, skipping...", githubOwner, githubRepo, currentCommitSHA)
		return nil
	}

	// When new version is published regenerate data
	url := fmt.Sprintf("https://api.github.com/repos/%s/%s/contents/%s?ref=%s", githubOwner, githubRepo, githubRepoSubdir, branch)
	repoEntries, err := getGithubSubRepoAndExtractContent(ctx, url)
	if err != nil {
		return fmt.Errorf("get github sub repo and extract content: %s", err)
	}

	manufacturers := []string{}
	manufacturersTrimmed := []string{}
	manufacturer2deviceType2deviceData := map[string]map[string]*devices.DeviceData{}
	for _, entry := range repoEntries {
		if entry.Type == "dir" {
			manufacturerEntries, err := getGithubSubRepoAndExtractContent(ctx, entry.URL)
			if err != nil {
				return fmt.Errorf("get github subRepo and extract content: %s", err)
			}
			for _, manufacturerEntry := range manufacturerEntries {
				if manufacturerEntry.Type == "file" && (strings.HasSuffix(manufacturerEntry.Name, ".yml") || strings.HasSuffix(manufacturerEntry.Name, ".yaml")) {
					obj, err := getObjectFromFile(ctx, manufacturerEntry.URL)
					if err != nil {
						return fmt.Errorf("get object from file: %s", err)
					}
					manufacturerName := entry.Name
					manufacturerNameTrimmed := trimManufacturer(manufacturerName)
					if _, ok := manufacturer2deviceType2deviceData[manufacturerName]; !ok {
						manufacturer2deviceType2deviceData[manufacturerName] = make(map[string]*devices.DeviceData)
						manufacturers = append(manufacturers, manufacturerName)
						manufacturersTrimmed = append(manufacturersTrimmed, manufacturerNameTrimmed)
					}
					manufacturer2deviceType2deviceData[manufacturerName][obj.Model] = obj
				}
			}
		}
	}

	// Generate manufacturer files
	for manufacturer, deviceData := range manufacturer2deviceType2deviceData {
		err = createManufacturerTemplate(manufacturer, deviceData)
		if err != nil {
			return fmt.Errorf("create manufacturer template: %s", err)
		}
	}

	// Generate combined file
	err = createCombinedTemplate(manufacturers, manufacturersTrimmed)
	if err != nil {
		return fmt.Errorf("create combined template: %s", err)
	}

	if err = writeSHAToFile(currentCommitSHA, shaCommitFile); err != nil {
		return fmt.Errorf("write SHA to file: %s", err)
	}
	return nil
}

func main() {
	if err := run(); err != nil {
		log.Fatalf("%v", err)
	}
}
